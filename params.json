{"name":"Read-word-file-in-to-php-","tagline":"PHP DOC DOCX PDF to Text: Convert DOCX, DOC, PDF to plain text  Please create a two php file for convert a word or pdf file into plan text that you can read all word or pdf  file in text format.","body":"Read word file in to php\r\n\r\nHello Guys,\r\nPHP DOC DOCX PDF to Text: Convert DOCX, DOC, PDF to plain text\r\n\r\nPlease create a two php file for convert a word or pdf file into plan text that you can read all word or pdf  file in text format.\r\n\r\nStep 1\r\n\r\nrequire(“classtext.php”);\r\n\r\n$docObj = new Filetotext(“Meta-Tags-Fitpass.docx”);\r\n//$docObj = new Filetotext(“test.pdf”);\r\n$return = $docObj->convertToText();\r\nvar_dump(explode(”,$return));\r\nvar_dump(extract_numbers($return));\r\nfunction extract_numbers($string){\r\npreg_match_all(‘/([\\d]+)/’, $string, $match);\r\n\r\nreturn $match[0];\r\n}\r\n\r\nvar_dump(extract_email_address( $return ) );\r\nfunction extract_email_address ($string) {\r\nforeach(preg_split(‘/\\s/’, $string) as $token) {\r\n$email = filter_var(filter_var($token, FILTER_SANITIZE_EMAIL), FILTER_VALIDATE_EMAIL);\r\nif ($email !== false) {\r\n$emails[] = str_replace(‘Email’,”,$email);\r\n}\r\n}\r\nreturn $emails;\r\n}\r\n\r\n \r\n\r\nStep-2 save file name with classtext.php\r\n\r\n<?php\r\nclass classtext {\r\n\r\nprivate $filename;\r\nvar $multibyte = 4; // Use setUnicode(TRUE|FALSE)\r\nvar $convertquotes = ENT_QUOTES; // ENT_COMPAT (double-quotes), ENT_QUOTES (Both), ENT_NOQUOTES (None)\r\nvar $showprogress = true; // TRUE if you have problems with time-out\r\nvar $decodedtext = ”;\r\n\r\npublic function __construct($filePath) {\r\n$this->filename = $filePath;\r\n}\r\n\r\npublic function convertToText() {\r\n\r\nif(isset($this->filename) && !file_exists($this->filename)) {\r\nreturn “File Not exists”;\r\n}\r\n\r\n$fileArray = pathinfo($this->filename);\r\n$file_ext = $fileArray[‘extension’];\r\nif($file_ext == “doc” || $file_ext == “docx”)\r\n{\r\nif($file_ext == “doc”) {\r\nreturn $this->read_doc();\r\n} else {\r\nreturn $this->read_docx();\r\n}\r\n} else if( $file_ext == “pdf” ){\r\n$this->setFilename( $this->filename );\r\n$this->decodePDF();\r\nreturn $this->output();\r\n} else {\r\nreturn “Invalid File Type”;\r\n}\r\n}\r\n\r\nprivate function read_doc() {\r\n$fileHandle = fopen($this->filename, “r”);\r\n$line = @fread($fileHandle, filesize($this->filename));\r\n$lines = explode(chr(0x0D),$line);\r\n$outtext = “”;\r\nforeach($lines as $thisline)\r\n{\r\n$pos = strpos($thisline, chr(0x00));\r\nif (($pos !== FALSE)||(strlen($thisline)==0))\r\n{\r\n} else {\r\n$outtext .= $thisline.” “;\r\n}\r\n}\r\n$outtext = preg_replace(“/[^a-zA-Z0-9\\s\\,\\.\\-\\n\\r\\t@\\/\\_\\(\\)]/”,””,$outtext);\r\nreturn $outtext;\r\n}\r\n\r\nprivate function read_docx(){\r\n\r\n$striped_content = ”;\r\n$content = ”;\r\n\r\n$zip = zip_open($this->filename);\r\n\r\nif (!$zip || is_numeric($zip)) return false;\r\n\r\nwhile ($zip_entry = zip_read($zip)) {\r\n\r\nif (zip_entry_open($zip, $zip_entry) == FALSE) continue;\r\n\r\nif (zip_entry_name($zip_entry) != “word/document.xml”) continue;\r\n\r\n$content .= zip_entry_read($zip_entry, zip_entry_filesize($zip_entry));\r\n\r\nzip_entry_close($zip_entry);\r\n}\r\n\r\nzip_close($zip);\r\n\r\n$content = str_replace(‘</w:r></w:p></w:tc><w:tc>’, ” “, $content);\r\n$content = str_replace(‘</w:r></w:p>’, “\\r\\n”, $content);\r\n$striped_content = strip_tags($content);\r\n\r\nreturn $striped_content;\r\n}\r\n\r\nprivate function setFilename($filename) {\r\n$this->decodedtext = ”;\r\n$this->filename = $filename;\r\n}\r\n\r\nprivate function output($echo = false) {\r\nif($echo) echo $this->decodedtext;\r\nelse return $this->decodedtext;\r\n}\r\n\r\nprivate function setUnicode($input) {\r\nif($input == true) $this->multibyte = 4;\r\nelse $this->multibyte = 2;\r\n}\r\n\r\nprivate function decodePDF() {\r\n$infile = @file_get_contents($this->filename, FILE_BINARY);\r\nif (empty($infile))\r\nreturn “”;\r\n\r\n$transformations = array();\r\n$texts = array();\r\n\r\npreg_match_all(“#obj[\\n|\\r](.*)endobj[\\n|\\r]#ismU”, $infile . “endobj\\r”, $objects);\r\n$objects = @$objects[1];\r\n\r\nfor ($i = 0; $i < count($objects); $i++) {\r\n$currentObject = $objects[$i];\r\n\r\n@set_time_limit ();\r\nif($this->showprogress) {\r\nflush(); ob_flush();\r\n}\r\n\r\nif (preg_match(“#stream[\\n|\\r](.*)endstream[\\n|\\r]#ismU”, $currentObject . “endstream\\r”, $stream )) {\r\n$stream = ltrim($stream[1]);\r\n$options = $this->getObjectOptions($currentObject);\r\n\r\nif (!(empty($options[“Length1”]) && empty($options[“Type”]) && empty($options[“Subtype”])) )\r\n// if ( $options[“Image”] && $options[“Subtype”] )\r\n// if (!(empty($options[“Length1”]) && empty($options[“Subtype”])) )\r\ncontinue;\r\n\r\nunset($options[“Length”]);\r\n\r\n$data = $this->getDecodedStream($stream, $options);\r\n\r\nif (strlen($data)) {\r\nif (preg_match_all(“#BT[\\n|\\r](.*)ET[\\n|\\r]#ismU”, $data . “ET\\r”, $textContainers)) {\r\n$textContainers = @$textContainers[1];\r\n$this->getDirtyTexts($texts, $textContainers);\r\n} else\r\n$this->getCharTransformations($transformations, $data);\r\n}\r\n}\r\n}\r\n\r\n$this->decodedtext = $this->getTextUsingTransformations($texts, $transformations);\r\n}\r\nprivate function decodeAsciiHex($input) {\r\n$output = “”;\r\n\r\n$isOdd = true;\r\n$isComment = false;\r\n\r\nfor($i = 0, $codeHigh = -1; $i < strlen($input) && $input[$i] != ‘>’; $i++) {\r\n$c = $input[$i];\r\n\r\nif($isComment) {\r\nif ($c == ‘\\r’ || $c == ‘\\n’)\r\n$isComment = false;\r\ncontinue;\r\n}\r\n\r\nswitch($c) {\r\ncase ‘\\0’: case ‘\\t’: case ‘\\r’: case ‘\\f’: case ‘\\n’: case ‘ ‘: break;\r\ncase ‘%’:\r\n$isComment = true;\r\nbreak;\r\n\r\ndefault:\r\n$code = hexdec($c);\r\nif($code === 0 && $c != ‘0’)\r\nreturn “”;\r\n\r\nif($isOdd)\r\n$codeHigh = $code;\r\nelse\r\n$output .= chr($codeHigh * 16 + $code);\r\n\r\n$isOdd = !$isOdd;\r\nbreak;\r\n}\r\n}\r\n\r\nif($input[$i] != ‘>’)\r\nreturn “”;\r\n\r\nif($isOdd)\r\n$output .= chr($codeHigh * 16);\r\n\r\nreturn $output;\r\n}\r\n\r\nprivate function decodeAscii85($input) {\r\n$output = “”;\r\n\r\n$isComment = false;\r\n$ords = array();\r\n\r\nfor($i = 0, $state = 0; $i < strlen($input) && $input[$i] != ‘~’; $i++) {\r\n$c = $input[$i];\r\n\r\nif($isComment) {\r\nif ($c == ‘\\r’ || $c == ‘\\n’)\r\n$isComment = false;\r\ncontinue;\r\n}\r\n\r\nif ($c == ‘\\0’ || $c == ‘\\t’ || $c == ‘\\r’ || $c == ‘\\f’ || $c == ‘\\n’ || $c == ‘ ‘)\r\ncontinue;\r\nif ($c == ‘%’) {\r\n$isComment = true;\r\ncontinue;\r\n}\r\nif ($c == ‘z’ && $state === 0) {\r\n$output .= str_repeat(chr(0), 4);\r\ncontinue;\r\n}\r\nif ($c < ‘!’ || $c > ‘u’)\r\nreturn “”;\r\n\r\n$code = ord($input[$i]) & 0xff;\r\n$ords[$state++] = $code – ord(‘!’);\r\n\r\nif ($state == 5) {\r\n$state = 0;\r\nfor ($sum = 0, $j = 0; $j < 5; $j++)\r\n$sum = $sum * 85 + $ords[$j];\r\nfor ($j = 3; $j >= 0; $j–)\r\n$output .= chr($sum >> ($j * 8));\r\n}\r\n}\r\nif ($state === 1)\r\nreturn “”;\r\nelseif ($state > 1) {\r\nfor ($i = 0, $sum = 0; $i < $state; $i++)\r\n$sum += ($ords[$i] + ($i == $state – 1)) * pow(85, 4 – $i);\r\nfor ($i = 0; $i < $state – 1; $i++) {\r\ntry {\r\nif(false == ($o = chr($sum >> ((3 – $i) * 8)))) {\r\nthrow new Exception(‘Error’);\r\n}\r\n$output .= $o;\r\n} catch (Exception $e) { /*Dont do anything*/ }\r\n}\r\n}\r\n\r\nreturn $output;\r\n}\r\n\r\nprivate function decodeFlate($data) {\r\nreturn @gzuncompress($data);\r\n}\r\n\r\nprivate function getObjectOptions($object) {\r\n$options = array();\r\n\r\nif (preg_match(“#<<(.*)>>#ismU”, $object, $options)) {\r\n$options = explode(“/”, $options[1]);\r\n@array_shift($options);\r\n\r\n$o = array();\r\nfor ($j = 0; $j < @count($options); $j++) {\r\n$options[$j] = preg_replace(“#\\s+#”, ” “, trim($options[$j]));\r\nif (strpos($options[$j], ” “) !== false) {\r\n$parts = explode(” “, $options[$j]);\r\n$o[$parts[0]] = $parts[1];\r\n} else\r\n$o[$options[$j]] = true;\r\n}\r\n$options = $o;\r\nunset($o);\r\n}\r\n\r\nreturn $options;\r\n}\r\n\r\nprivate function getDecodedStream($stream, $options) {\r\n$data = “”;\r\nif (empty($options[“Filter”]))\r\n$data = $stream;\r\nelse {\r\n$length = !empty($options[“Length”]) ? $options[“Length”] : strlen($stream);\r\n$_stream = substr($stream, 0, $length);\r\n\r\nforeach ($options as $key => $value) {\r\nif ($key == “ASCIIHexDecode”)\r\n$_stream = $this->decodeAsciiHex($_stream);\r\nelseif ($key == “ASCII85Decode”)\r\n$_stream = $this->decodeAscii85($_stream);\r\nelseif ($key == “FlateDecode”)\r\n$_stream = $this->decodeFlate($_stream);\r\nelseif ($key == “Crypt”) { // TO DO\r\n}\r\n}\r\n$data = $_stream;\r\n}\r\nreturn $data;\r\n}\r\n\r\nprivate function getDirtyTexts(&$texts, $textContainers) {\r\nfor ($j = 0; $j < count($textContainers); $j++) {\r\nif (preg_match_all(“#\\[(.*)\\]\\s*TJ[\\n|\\r]#ismU”, $textContainers[$j], $parts))\r\n$texts = array_merge($texts, array(@implode(”, $parts[1])));\r\nelseif (preg_match_all(“#T[d|w|m|f]\\s*(\\(.*\\))\\s*Tj[\\n|\\r]#ismU”, $textContainers[$j], $parts))\r\n$texts = array_merge($texts, array(@implode(”, $parts[1])));\r\nelseif (preg_match_all(“#T[d|w|m|f]\\s*(\\[.*\\])\\s*Tj[\\n|\\r]#ismU”, $textContainers[$j], $parts))\r\n$texts = array_merge($texts, array(@implode(”, $parts[1])));\r\n}\r\n\r\n}\r\n\r\nprivate function getCharTransformations(&$transformations, $stream) {\r\npreg_match_all(“#([0-9]+)\\s+beginbfchar(.*)endbfchar#ismU”, $stream, $chars, PREG_SET_ORDER);\r\npreg_match_all(“#([0-9]+)\\s+beginbfrange(.*)endbfrange#ismU”, $stream, $ranges, PREG_SET_ORDER);\r\n\r\nfor ($j = 0; $j < count($chars); $j++) {\r\n$count = $chars[$j][1];\r\n$current = explode(“\\n”, trim($chars[$j][2]));\r\nfor ($k = 0; $k < $count && $k < count($current); $k++) {\r\nif (preg_match(“#<([0-9a-f]{2,4})>\\s+<([0-9a-f]{4,512})>#is”, trim($current[$k]), $map))\r\n$transformations[str_pad($map[1], 4, “0”)] = $map[2];\r\n}\r\n}\r\nfor ($j = 0; $j < count($ranges); $j++) {\r\n$count = $ranges[$j][1];\r\n$current = explode(“\\n”, trim($ranges[$j][2]));\r\nfor ($k = 0; $k < $count && $k < count($current); $k++) {\r\nif (preg_match(“#<([0-9a-f]{4})>\\s+<([0-9a-f]{4})>\\s+<([0-9a-f]{4})>#is”, trim($current[$k]), $map)) {\r\n$from = hexdec($map[1]);\r\n$to = hexdec($map[2]);\r\n$_from = hexdec($map[3]);\r\n\r\nfor ($m = $from, $n = 0; $m <= $to; $m++, $n++)\r\n$transformations[sprintf(“%04X”, $m)] = sprintf(“%04X”, $_from + $n);\r\n} elseif (preg_match(“#<([0-9a-f]{4})>\\s+<([0-9a-f]{4})>\\s+\\[(.*)\\]#ismU”, trim($current[$k]), $map)) {\r\n$from = hexdec($map[1]);\r\n$to = hexdec($map[2]);\r\n$parts = preg_split(“#\\s+#”, trim($map[3]));\r\n\r\nfor ($m = $from, $n = 0; $m <= $to && $n < count($parts); $m++, $n++)\r\n$transformations[sprintf(“%04X”, $m)] = sprintf(“%04X”, hexdec($parts[$n]));\r\n}\r\n}\r\n}\r\n}\r\nprivate function getTextUsingTransformations($texts, $transformations) {\r\n$document = “”;\r\nfor ($i = 0; $i < count($texts); $i++) {\r\n$isHex = false;\r\n$isPlain = false;\r\n\r\n$hex = “”;\r\n$plain = “”;\r\nfor ($j = 0; $j < strlen($texts[$i]); $j++) {\r\n$c = $texts[$i][$j];\r\nswitch($c) {\r\ncase “<“:\r\n$hex = “”;\r\n$isHex = true;\r\n$isPlain = false;\r\nbreak;\r\ncase “>”:\r\n$hexs = str_split($hex, $this->multibyte); // 2 or 4 (UTF8 or ISO)\r\nfor ($k = 0; $k < count($hexs); $k++) {\r\n\r\n$chex = str_pad($hexs[$k], 4, “0”); // Add tailing zero\r\nif (isset($transformations[$chex]))\r\n$chex = $transformations[$chex];\r\n$document .= html_entity_decode(“&#x”.$chex.”;”);\r\n}\r\n$isHex = false;\r\nbreak;\r\ncase “(“:\r\n$plain = “”;\r\n$isPlain = true;\r\n$isHex = false;\r\nbreak;\r\ncase “)”:\r\n$document .= $plain;\r\n$isPlain = false;\r\nbreak;\r\ncase “\\\\”:\r\n$c2 = $texts[$i][$j + 1];\r\nif (in_array($c2, array(“\\\\”, “(“, “)”))) $plain .= $c2;\r\nelseif ($c2 == “n”) $plain .= ‘\\n’;\r\nelseif ($c2 == “r”) $plain .= ‘\\r’;\r\nelseif ($c2 == “t”) $plain .= ‘\\t’;\r\nelseif ($c2 == “b”) $plain .= ‘\\b’;\r\nelseif ($c2 == “f”) $plain .= ‘\\f’;\r\nelseif ($c2 >= ‘0’ && $c2 <= ‘9’) {\r\n$oct = preg_replace(“#[^0-9]#”, “”, substr($texts[$i], $j + 1, 3));\r\n$j += strlen($oct) – 1;\r\n$plain .= html_entity_decode(“&#”.octdec($oct).”;”, $this->convertquotes);\r\n}\r\n$j++;\r\nbreak;\r\n\r\ndefault:\r\nif ($isHex)\r\n$hex .= $c;\r\nelseif ($isPlain)\r\n$plain .= $c;\r\nbreak;\r\n}\r\n}\r\n$document .= “\\n”;\r\n}\r\n\r\nreturn $document;\r\n}\r\n\r\n}\r\n\r\n \r\n\r\nI have mention some code for how to read email from a string and phone number. Basically I am facing some issue when i trying to upload resume and want to read this file. I got some ideas that I can use preg_match_all function. If you will find better solution please let me know that I can change this code and our programmer can use essay this code.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}